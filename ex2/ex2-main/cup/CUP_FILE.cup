import java_cup.runtime.*;
import ast.*;

parser code
{:
	public Lexer lexer;

	public Parser(Lexer lexer)
	{
		super(lexer);
		this.lexer = lexer;
	}
	public void report_error(String message, Object info)
	{
		System.out.print("ERROR >> ");
		System.out.print("[");
		System.out.print(lexer.getLine());
		System.out.print(":");
		System.out.print(lexer.getTokenStartPosition());
		System.out.print("] ");
		System.exit(0);
	}
:}

/************************/
/* CUSTOMIZE CUP PARSER */
/************************/
scan with
{:
	Symbol s;
	s = lexer.next_token();
	//System.out.print(s.sym);
	System.out.print("[");
	System.out.print(lexer.getLine());
	System.out.print(":");
	System.out.print(lexer.getTokenStartPosition());
	System.out.print("] ");
	System.out.print(TokenNames.terminalNames[s.sym]);
	if (s.value != null)
	{
		System.out.print("( ");
		System.out.print(s.value);
		System.out.print(" )");
	}
	System.out.print("\n");
	return s;
:};

/*************/
/* TERMINALS */
/*************/
terminal IF;
terminal EQ;
terminal DOT;
terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal WHILE;
terminal DIVIDE;
terminal LPAREN;
terminal RPAREN;
terminal LBRACK;
terminal RBRACK;
terminal LBRACE;
terminal RBRACE;
terminal SEMICOLON;
terminal ASSIGN;
terminal EOF;
terminal COMMA;
terminal TYPE_INT;
terminal TYPE_STRING;
terminal TYPE_VOID;
terminal LT;
terminal GT;
terminal ARRAY;
terminal CLASS;
terminal RETURN;
terminal ELSE;
terminal NEW;
terminal EXTENDS;
terminal NIL;
terminal INT_W_LEADING_Z; // TODO needed?
terminal COMMENT;
terminal ERROR; // TODO needed?

/*************/
/* TERMINALS */
/*************/
terminal Integer INT;
terminal String ID;
terminal String STRING;

/*****************/
/* NON TERMINALS */
/*****************/
non terminal AstExp exp;
non terminal AstVar var;
non terminal AstStmt stmt;
non terminal AstStmtList stmtList;

non terminal AstDecList program;
non terminal AstDecList decList;
non terminal AstDec dec;

non terminal AstVarType type;
non terminal AstVarDec varDec;
non terminal AstFuncDec funcDec;
non terminal AstClassDec classDec;
non terminal AstCFieldList cFieldList;
non terminal AstCField cField;
non terminal AstNewExp newExp;
non terminal AstExpCall callExp;
non terminal AstDecArray arrayTypedef;
non terminal AstTypeIdList typeIdList;
non terminal AstExpInt intExp;
non terminal AstExpNIL nilExp;

// TODO hila: GPT suggested these as well. Please make sure they weren't missed. If were, just rm
non terminal AstStmtAssign assignStmt;
non terminal AstStmtReturn returnStmt;
non terminal AstStmtIf ifStmt;
non terminal AstStmtWhile whileStmt;


/***********************/
/* OPERATOR PRECEDENCE */
/***********************/
precedence left PLUS;
precedence left MINUS;
precedence left TIMES;
precedence left DIVIDE;

/************************/
/* START WITH: stmtList */
/************************/
start with stmtList;

/********************/
/* DERIVATION RULES */
/********************/

program 	::= 	decList:l	 													{: RESULT = l; 										:}
					;

decList		:=		dec:d	decList:l												{: RESULT = new AstDecList(d,l);    				:}
					| dec:d															{: RESULT = new AstDecList(d,null); 				:}
					;

dec 		::=		varDec:vDec          											{: RESULT = vDec; 									:}
    				| funcDec:fDec       											{: RESULT = fDec; 									:}
    				| classDec:cDec      											{: RESULT = cDec; 									:}
    				| arrayTypedef:aDec  											{: RESULT = aDec; 									:}
    				;

type 		::=		TYPE_INT          												{: RESULT = new AstVarType("int"); 					:} // TODO Yamit: make sure "AstVarType" is the proper type
					| TYPE_STRING     												{: RESULT = new AstVarType("string"); 				:}
    				| TYPE_VOID       												{: RESULT = new AstVarType("void"); 				:}
    				| ID:name         												{: RESULT = new AstVarType(name); 					:} // TODO Yamit: make sure this is the proper type. ID is a str - will that work?
    				;

varDec 		::= 	type:t ID:i ASSIGN exp:e SEMICOLON 								{: RESULT = new AstVarDec(t,i,e); 					:}
					| type:t ID:i SEMICOLON											{: RESULT = new AstVarDec(t,i,null); 				:}
					| type:t ID:i ASSIGN newExp:nE SEMICOLON						{: RESULT = new AstVarDec(t,i,nE); 					:}
					;

stmtList	::=		stmt:s	stmtList:l												{: RESULT = new AstStmtList(s,l);    				:}
					| stmt:s														{: RESULT = new AstStmtList(s,null); 				:}
					;

cFieldList	::=		cField:c	cFieldList:l										{: RESULT = new AstCFieldList(c,l);    				:}
					| cField:c														{: RESULT = new AstCFieldList(c,null); 				:}
					;

funcDec 	::= 	type:t ID:i LPAREN typeIdList:l RPAREN LBRACE stmtList:s RBRACE {: RESULT = new AstDecFunc(t,i,l,s);    			:}
					| type:t ID:i LPAREN RPAREN LBRACE stmtList:s RBRACE			{: RESULT = new AstDecFunc(t,i,null,s);    			:}
					;

// TODO Hila: Regarding "typeIdList" please note, this is a direct sub-group of stmntList. Why would we want a sepetate Ast class for var declerations?
// [var decleration = type and ID] is specifically a stmt.
// There is generally a pretty big mess here with types and their implied hierarchy, might be caused by these duplications. We need to talk about it,
// or better yet, perhaps create and agree on some diagram of all classes, who derives from who, simplest ex. to easily differ...

// typeIdList	::=		type:t ID:i COMMA typeIdList:l									{: RESULT = new AstTypeIdList(t,i,l);    			:}
// 					| type:t ID:i													{: RESULT = new AstTypeIdList(t,i,null);    		:}
// 					;

classDec 	::= 	CLASS ID:name EXTENDS ID:parentName LBRACE cFieldList:l RBRACE	{: RESULT = new AstDecClass(name,parentNmae,l); 	:}
					| CLASS ID:name LBRACE cFieldList:l RBRACE						{: RESULT = new AstDecClass(name,null,l); 			:}
					;

cField 		::= 	varDec:vDec 													{: RESULT = vDec; 									:}
					| funcDec:fDec													{: RESULT = fDec; 									:}
					;

arrayTypedef ::= 	ARRAY ID:i EQ type:t LBRACK RBRACK SEMICOLON					{: RESULT = new AstDecArray(i,t); 					:}
					;

exp 		::= 	var:v															{: RESULT = new AstExpVar(v); 						:}
					| LPAREN exp:e RPAREN											{: RESULT = e; 										:}
					| exp:e1 PLUS exp:e2											{: RESULT = new AstExpBinop(e1, e2, 0); 			:}
					| exp:e1 MINUS exp:e2											{: RESULT = new AstExpBinop(e1, e2, 1); 			:}
					| exp:e1 TIMES exp:e2											{: RESULT = new AstExpBinop(e1, e2, 2); 			:}
					| exp:e1 DIVIDE exp:e2											{: RESULT = new AstExpBinop(e1, e2, 3); 			:}
					| exp:e1 LT exp:e2												{: RESULT = new AstExpBinop(e1, e2, 4); 			:}
					| exp:e1 GT exp:e2												{: RESULT = new AstExpBinop(e1, e2, 5); 			:}
					| exp:e1 EQ exp:e2												{: RESULT = new AstExpBinop(e1, e2, 6); 			:}
					| callExp:c														{: RESULT = c; 										:}
					| MINUS INT:i													{: RESULT = new AstExpInt(i, true); 				:}
					| INT:i 														{: RESULT = new AstExpInt(i, false); 				:}
					| NIL															{: RESULT = new AstExpNIL(); 						:}
					| STRING:s														{: RESULT = s; 										:}
					;

newExp 		::= 	NEW type:t 														{: RESULT = new AstNewExp(t, null); 				:}
					| NEW type:t LBRACK exp:e RBRACK								{: RESULT = new AstNewExp(t, e); 					:}
					;

callExp 	::= 	var:v DOT ID:i LPAREN expList:l RPAREN 							{: RESULT = new AstCallExp(v,i,l);    				:}
					| var:v DOT ID:i LPAREN RPAREN									{: RESULT = new AstCallExp(v,i,null);    			:}
					| ID:i LPAREN expList:l RPAREN 									{: RESULT = new AstCallExp(null,i,l);    			:}
					| ID:i LPAREN RPAREN											{: RESULT = new AstCallExp(null,i,null);    		:}
					;

expList		::=		exp:e COMMA expList:l											{: RESULT = new AstExpList(e,l);    				:}
					| exp:e															{: RESULT = new AstExpList(e,null);    				:}
					;

var			::=		ID:name															{: RESULT = new AstVarSimple(name);       			:} // TODO Yamit: make sure "AstVarSimple" is the proper type
					| var:v DOT ID:fieldName										{: RESULT = new AstVarField(v,fieldName); 			:}
					| var:v LBRACK exp:e RBRACK										{: RESULT = new AstVarSubscript(v,e);     			:}
					;

stmt 		::= 	varDec:vDec														{: RESULT = vDec; 									:} // so varDec must implement stmt
					| var:v ASSIGN exp:e SEMICOLON									{: RESULT = new AstStmtAssign(v,e); 				:}
					| var:v ASSIGN newExp:nExp SEMICOLON							{: RESULT = new AstStmtAssignNew(v,nExp); 			:}
					| RETURN exp:e SEMICOLON										{: RESULT = new AstStmtReturn(ret); 				:}
					| RETURN SEMICOLON												{: RESULT = new AstStmtReturn(null); 				:}
					| IF LPAREN exp:cond RPAREN LBRACE stmtList:body RBRACE
					  ELSE LBRACE stmtList:elseBody RBRACE 							{: RESULT = new AstStmtIf(cond,body,elseBody); 		:} // if-else must come before if
					| IF LPAREN exp:cond RPAREN LBRACE stmtList:body RBRACE 		{: RESULT = new AstStmtIf(cond,body); 				:}
					| WHILE LPAREN exp:cond RPAREN LBRACE stmtList:body RBRACE 		{: RESULT = new AstStmtWhile(cond,body); 			:}
					| callExp:c SEMICOLON											{: RESULT = c; 										:}
					;
