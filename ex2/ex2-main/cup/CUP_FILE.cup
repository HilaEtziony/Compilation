/*************/
/* IMPORT(S) */
/*************/
import java_cup.runtime.*;
import ast.*;

parser code 
{:
	public Lexer lexer;

	public Parser(Lexer lexer)
	{
		super(lexer);
		this.lexer = lexer;
	}
	public void report_error(String message, Object info)
	{
		System.out.print("ERROR >> ");		
		System.out.print("[");
		System.out.print(lexer.getLine());
		System.out.print(":");
		System.out.print(lexer.getTokenStartPosition());
		System.out.print("] ");		
		System.exit(0);
	}
:}

/************************/
/* CUSTOMIZE CUP PARSER */
/************************/
scan with
{:
	Symbol s;
	s = lexer.next_token();
	//System.out.print(s.sym);
	System.out.print("[");
	System.out.print(lexer.getLine());
	System.out.print(":");
	System.out.print(lexer.getTokenStartPosition());
	System.out.print("] ");
	System.out.print(TokenNames.terminalNames[s.sym]);
	if (s.value != null)
	{
		System.out.print("( ");
		System.out.print(s.value);
		System.out.print(" )");
	}
	System.out.print("\n");
	return s; 
:};

/*************/
/* TERMINALS */
/*************/
terminal IF;
terminal EQ;
terminal DOT;
terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal WHILE;
terminal DIVIDE;
terminal LPAREN;
terminal RPAREN;
terminal LBRACK;
terminal RBRACK;
terminal LBRACE;
terminal RBRACE;
terminal SEMICOLON;
terminal ASSIGN;
terminal EOF;
terminal COMMA;
terminal TYPE_INT;
terminal TYPE_STRING;
terminal TYPE_VOID;
terminal LT;
terminal GT;
terminal ARRAY;
terminal CLASS;
terminal RETURN;
terminal ELSE;
terminal NEW;
terminal EXTENDS;
terminal NIL;
terminal INT_W_LEADING_Z; // TODO needed?
terminal COMMENT;
terminal ERROR; // TODO needed?

/*************/
/* TERMINALS */
/*************/
terminal Integer INT;
terminal String ID;
terminal String STRING;

/*****************/
/* NON TERMINALS */
/*****************/
non terminal AstExp exp;
non terminal AstVar var;
non terminal AstStmt stmt;
non terminal AstStmtList stmtList;

non terminal AstDecList program;
non terminal AstDecList decList;
non terminal AstDec dec;

/***********************/
/* OPERATOR PRECEDENCE */
/***********************/
precedence left PLUS;
precedence left MINUS;
precedence left TIMES;
precedence left DIVIDE;

/************************/
/* START WITH: stmtList */
/************************/
start with stmtList;

/********************/
/* DERIVATION RULES */
/********************/

program 	::= 	decList:l	 													{: RESULT = l; 									:}
					;

decList		:=		dec:d	decList:l												{: RESULT = new AstDecList(d,l);    			:}  //TODO - create AstDecList extends AstNode (as AstStmtList extends AstNode)
					| dec:d															{: RESULT = new AstDecList(d,null); 			:}	//TODO - the same as above
					;

dec 		::=		varDec:vDec          											{: RESULT = vDec; 								:}	//TODO - create AstDecList extends AstNode (as AstStmt extends AstNode)
    				| funcDec:fDec       											{: RESULT = fDec; 								:}	//TODO - the same as above
    				| classDec:cDec      											{: RESULT = cDec; 								:}  //TODO - the same as above
    				| arrayTypedef:aDec  											{: RESULT = aDec; 								:}  //TODO - the same as above
    				;

type 		::=		TYPE_INT          												{: RESULT = "int"; 								:}
					| TYPE_STRING     												{: RESULT = "string"; 							:}
    				| TYPE_VOID       												{: RESULT = "void"; 							:}
    				| ID:name         												{: RESULT = name; 								:}
    				;

varDec 		::= 	type:t ID:i ASSIGN exp:e SEMICOLON
					| type:t ID:i SEMICOLON
					| type:t ID:i ASSIGN newExp:nE SEMICOLON
					;

funcDec 	::= 	type:t ID:i LPAREN type:t_inner ID:i_inner { COMMA type ID } RPAREN LBRACE stmtList:s RBRACE //TODO - take care in { COMMA type ID }
					| type:t ID:i LPAREN RPAREN LBRACE stmtList:s RBRACE
					;

stmtList	::=		stmt:s	stmtList:l												{: RESULT = new AstStmtList(s,l);    			:}
					| stmt:s														{: RESULT = new AstStmtList(s,null); 			:}
					;

classDec 	::= 	CLASS ID:name EXTENDS ID:parentName 
					LBRACE cField:c	cFieldList:l RBRACE
					| CLASS ID:name EXTENDS ID:parentName 
					  LBRACE cField:c RBRACE
					| CLASS ID:name LBRACE cField:c	cFieldList:l RBRACE
					| CLASS ID:name LBRACE cField:c RBRACE
					;

cFieldList	::=		cField:c	cFieldList:l										{: RESULT = new AstCFieldList(c,l);    			:} //TODO - create AstCFieldList
					| cField:c														{: RESULT = new AstCFieldList(c,null); 			:} //TODO - create AstCFieldList
					;

cField 		::= 	varDec:vDec 													{: RESULT = vDec; 								:}
					| funcDec:fDec													{: RESULT = fDec; 								:}
					;

arrayTypedef ::= 	ARRAY ID:i EQ type:t LBRACK RBRACK SEMICOLON
					;

exp 		::= 	var:v															{: RESULT = new AstExpVar(v); 					:}
					| LPAREN exp:e RPAREN											{: RESULT = e; :}
					| exp:e1 PLUS exp:e2											{: RESULT = new AstExpBinop(e1, e2, 0); 		:}
					| exp:e1 MINUS exp:e2											{: RESULT = new AstExpBinop(e1, e2, 1); 		:}
					| exp:e1 TIMES exp:e2											{: RESULT = new AstExpBinop(e1, e2, 2); 		:}
					| exp:e1 DIVIDE exp:e2											{: RESULT = new AstExpBinop(e1, e2, 3); 		:}
					| exp:e1 LT exp:e2												{: RESULT = new AstExpBinop(e1, e2, 4); 		:}
					| exp:e1 GT exp:e2												{: RESULT = new AstExpBinop(e1, e2, 5); 		:}
					| exp:e1 EQ exp:e2												{: RESULT = new AstExpBinop(e1, e2, 6); 		:}
					| callExp:c														{: RESULT = c; 									:}
					| MINUS INT:i 
					| INT:i 														{: RESULT = new AstExpInt(i); 					:}
					| NIL 
					| STRING:s														{: RESULT = s; 									:}														
					;

newExp 		::= 	NEW type:t
					| NEW type:t LBRACK exp:e RBRACK
					;

callExp 	::= 	var:v DOT ID:name LPAREN exp { COMMA exp } RPAREN //TODO - take care in { COMMA exp }
					| var:v DOT ID:name LPAREN RPAREN
					| ID:name LPAREN exp { COMMA exp } RPAREN //TODO - take care in { COMMA exp }
					| ID:name LPAREN RPAREN
					;

var			::=		ID:name															{: RESULT = new AstVarSimple(name);       		:}
					| var:v DOT ID:fieldName										{: RESULT = new AstVarField(v,fieldName); 		:}
					| var:v LBRACK exp:e RBRACK										{: RESULT = new AstVarSubscript(v,e);     		:}
					;

stmt 		::= 	varDec:vDec														{: RESULT = vDec; 								:}	//TODO - create AstDecList extends AstNode (as AstStmt extends AstNode)
					| var ASSIGN exp SEMICOLON										{: RESULT = new AstStmtAssign(v,e); 			:}
					| var ASSIGN newExp SEMICOLON
					| RETURN exp:e SEMICOLON										{: RESULT = new AstStmtReturn(ret); 			:}
					| RETURN SEMICOLON												{: RESULT = new AstStmtReturn(null); 			:}
					| IF LPAREN exp:cond RPAREN LBRACE stmtList:body RBRACE 
					  ELSE LBRACE stmtList:elseBody RBRACE 							{: RESULT = new AstStmtIf(cond,body,elseBody); 	:} //if else must be before if
					| IF LPAREN exp:cond RPAREN LBRACE stmtList:body RBRACE 		{: RESULT = new AstStmtIf(cond,body); 			:}
					| WHILE LPAREN exp:cond RPAREN LBRACE stmtList:body RBRACE 		{: RESULT = new AstStmtWhile(cond,body); 		:}
					| callExp:c SEMICOLON											{: RESULT = c; 									:}
					;