import java_cup.runtime.*;
import ast.*;

parser code
{:
	public Lexer lexer;

	public Parser(Lexer lexer)
	{
		super(lexer);
		this.lexer = lexer;
	}
	public void report_error(String message, Object info)
	{
		System.out.print("ERROR >> ");
		System.out.print("[");
		System.out.print(lexer.getLine());
		System.out.print(":");
		System.out.print(lexer.getTokenStartPosition());
		System.out.print("] ");
		throw new Error("ERROR("+lexer.getLine()+")");
	}
:}

/************************/
/* CUSTOMIZE CUP PARSER */
/************************/
scan with
{:
	Symbol s;
	s = lexer.next_token();
	//System.out.print(s.sym);
	System.out.print("[");
	System.out.print(lexer.getLine());
	System.out.print(":");
	System.out.print(lexer.getTokenStartPosition());
	System.out.print("] ");
	System.out.print(TokenNames.terminalNames[s.sym]);
	if (s.value != null)
	{
		System.out.print("( ");
		System.out.print(s.value);
		System.out.print(" )");
	}
	System.out.print("\n");
	return s;
:};

/*************/
/* TERMINALS */
/*************/
terminal IF;
terminal EQ;
terminal DOT;
terminal PLUS;
terminal MINUS;
terminal TIMES;
terminal WHILE;
terminal DIVIDE;
terminal LPAREN;
terminal RPAREN;
terminal LBRACK;
terminal RBRACK;
terminal LBRACE;
terminal RBRACE;
terminal SEMICOLON;
terminal ASSIGN;
terminal COMMA;
terminal TYPE_INT;
terminal TYPE_STRING;
terminal TYPE_VOID;
terminal LT;
terminal GT;
terminal ARRAY;
terminal CLASS;
terminal RETURN;
terminal ELSE;
terminal NEW;
terminal EXTENDS;
terminal NIL;
terminal INT_W_LEADING_Z; // TODO needed?
terminal COMMENT;
terminal ERROR; // TODO needed?

/*************/
/* TERMINALS */
/*************/
terminal Integer INT;
terminal String ID;
terminal String STRING;

/*****************/
/* NON TERMINALS */
/*****************/
non terminal AstDecList program; 
non terminal AstDecList decList;
non terminal AstDec dec;
non terminal AstVarType type; 
non terminal AstVarDec varDec; 
non terminal AstStmtList stmtList;
non terminal AstDecFunc funcDec; 
non terminal AstTypeIdList typeIdList; 
non terminal AstDecClass classDec; 
non terminal AstDecList cFieldList; 
non terminal AstDec cField; 			// Explanation: cField == varDec/FunctDec - AstCfieldList/AstCfield/AstVarDec/AstDecFunc->AstDec->AstStmt->AstNode
non terminal AstDecArray arrayTypedef; 
non terminal AstExp exp; 
non terminal AstNewExp newExp; 
non terminal AstExpCall callExp; 
non terminal AstExpList expList; 
non terminal AstVar var; 
non terminal AstStmt stmt; 


/***********************/
/* OPERATOR PRECEDENCE */
/***********************/

precedence right ASSIGN;
precedence left EQ;
precedence left LT, GT;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence left DOT;
precedence left LBRACK;

/************************/
/* START WITH: stmtList */
/************************/
start with stmtList;

/********************/
/* DERIVATION RULES */
/********************/

program 	::= 	decList:l	 													{: RESULT = l; 										:}
					;

decList		::=		dec:d	decList:l												{: RESULT = new AstDecList(d,l);    				:}
					| dec:d															{: RESULT = new AstDecList(d,null); 				:}
					;

dec 		::=		varDec:vDec          											{: RESULT = vDec; 									:}
    				| funcDec:fDec       											{: RESULT = fDec; 									:}
    				| classDec:cDec      											{: RESULT = cDec; 									:}
    				| arrayTypedef:aDec  											{: RESULT = aDec; 									:}
    				;

type 		::=		TYPE_INT          												{: RESULT = new AstVarType("int"); 					:} // TODO Yamit: make sure "AstVarType" is the proper type
					| TYPE_STRING     												{: RESULT = new AstVarType("string"); 				:}
    				| TYPE_VOID       												{: RESULT = new AstVarType("void"); 				:}
    				| ID:name         												{: RESULT = new AstVarType(name); 					:} // TODO Yamit: make sure this is the proper type. ID is a str - will that work?
    				;

varDec 		::= 	type:t ID:i ASSIGN exp:e SEMICOLON 								{: RESULT = new AstVarDec(t,new AstVarSimple(i),e); 					:}
					| type:t ID:i SEMICOLON										{: RESULT = new AstVarDec(t,new AstVarSimple(i),null); 				:}
					| type:t ID:i ASSIGN newExp:nE SEMICOLON						{: RESULT = new AstVarDec(t,new AstVarSimple(i),nE); 					:}
					;

stmtList	::=		stmt:s	stmtList:l												{: RESULT = new AstStmtList(s,l);    				:}
					| stmt:s														{: RESULT = new AstStmtList(s,null); 				:}
					;

funcDec 	::= 	type:t ID:i LPAREN typeIdList:l RPAREN LBRACE stmtList:s RBRACE {: RESULT = new AstDecFunc(t,i,l,s);    			:}
					| type:t ID:i LPAREN RPAREN LBRACE stmtList:s RBRACE			{: RESULT = new AstDecFunc(t,i,null,s);    			:}
					;

typeIdList	::=		type:t ID:i COMMA typeIdList:l									{: RESULT = new AstTypeIdList(t,i,l);    			:}
					| type:t ID:i													{: RESULT = new AstTypeIdList(t,i,null);    		:}
					;

classDec 	::= 	CLASS ID:name EXTENDS ID:parentName LBRACE cFieldList:l RBRACE	{: RESULT = new AstDecClass(name,parentName,l); 	:}
					| CLASS ID:name LBRACE cFieldList:l RBRACE						{: RESULT = new AstDecClass(name,null,l); 			:}
					;

cFieldList	::=		cField:c	cFieldList:l										{: RESULT = new AstDecList(c,l);    				:}
					| cField:c														{: RESULT = new AstDecList(c,null); 				:}
					;

cField 		::= 	varDec:vDec 													{: RESULT = vDec; 									:}
					| funcDec:fDec													{: RESULT = fDec; 									:}
					;

arrayTypedef ::= 	ARRAY ID:i EQ type:t LBRACK RBRACK SEMICOLON					{: RESULT = new AstDecArray(i,t); 					:}
					;

exp 		::= 	var:v															{: RESULT = new AstExpVar(v); 						:}
					| LPAREN exp:e RPAREN											{: RESULT = e; 										:}
					| exp:e1 PLUS exp:e2											{: RESULT = new AstExpBinop(e1, e2, 0); 			:}
					| exp:e1 MINUS exp:e2											{: RESULT = new AstExpBinop(e1, e2, 1); 			:}
					| exp:e1 TIMES exp:e2											{: RESULT = new AstExpBinop(e1, e2, 2); 			:}
					| exp:e1 DIVIDE exp:e2											{: RESULT = new AstExpBinop(e1, e2, 3); 			:}
					| exp:e1 LT exp:e2												{: RESULT = new AstExpBinop(e1, e2, 4); 			:}
					| exp:e1 GT exp:e2												{: RESULT = new AstExpBinop(e1, e2, 5); 			:}
					| exp:e1 EQ exp:e2												{: RESULT = new AstExpBinop(e1, e2, 6); 			:}
					| callExp:c														{: RESULT = c; 										:}
					| MINUS INT:i													{: RESULT = new AstExpInt(i, true); 				:}
					| INT:i 														{: RESULT = new AstExpInt(i, false); 				:}
					| NIL															{: RESULT = new AstExpNIL(); 						:}
					| STRING:s														{: RESULT = new AstExpString(s); 					:}
					;

newExp 		::= 	NEW type:t 														{: RESULT = new AstNewExp(t, null); 				:}
					| NEW type:t LBRACK exp:e RBRACK								{: RESULT = new AstNewExp(t, e); 					:}
					;

callExp 	::= 	var:v DOT ID:i LPAREN expList:l RPAREN 							{: RESULT = new AstExpCall(v,i,l);    				:}
					| var:v DOT ID:i LPAREN RPAREN									{: RESULT = new AstExpCall(v,i,null);    			:}
					| ID:i LPAREN expList:l RPAREN 									{: RESULT = new AstExpCall(null,i,l);    			:}
					| ID:i LPAREN RPAREN											{: RESULT = new AstExpCall(null,i,null);    		:}
					;

expList		::=		exp:e COMMA expList:l											{: RESULT = new AstExpList(e,l);    				:}
					| exp:e															{: RESULT = new AstExpList(e,null);    				:}
					;

var			::=		ID:name															{: RESULT = new AstVarSimple(name);       			:} // TODO Yamit: make sure "AstVarSimple" is the proper type
					| var:v DOT ID:fieldName										{: RESULT = new AstVarField(v,fieldName); 			:}
					| var:v LBRACK exp:e RBRACK										{: RESULT = new AstVarSubscript(v,e);     			:}
					;

stmt 		::= 	varDec:vDec														{: RESULT = vDec; 									:} // so varDec must implement stmt
					| var:v ASSIGN exp:e SEMICOLON									{: RESULT = new AstStmtAssign(v,e); 				:}
					| var:v ASSIGN newExp:nExp SEMICOLON							{: RESULT = new AstStmtAssignNew(v,nExp); 			:}     // check if right logic wise
					| RETURN exp:e SEMICOLON										{: RESULT = new AstStmtReturn(e); 					:}
					| RETURN SEMICOLON												{: RESULT = new AstStmtReturn(null); 				:}
					| IF LPAREN exp:cond RPAREN LBRACE stmtList:body RBRACE
					  ELSE LBRACE stmtList:elseBody RBRACE 							{: RESULT = new AstStmtIf(cond,body,elseBody); 		:} // if-else must come before if
					| IF LPAREN exp:cond RPAREN LBRACE stmtList:body RBRACE 		{: RESULT = new AstStmtIf(cond,body); 				:}
					| WHILE LPAREN exp:cond RPAREN LBRACE stmtList:body RBRACE 		{: RESULT = new AstStmtWhile(cond,body); 			:}
					| callExp:c SEMICOLON											{: RESULT = new AstStmtCall(c); 						:}
					;
